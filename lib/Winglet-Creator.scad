///*** Create Winglet like a Wing ***///

///*** Main ***///
module CreateWinglet(){

    points_le = get_leading_edge_points();
    z_pos = wing_root_mm + wing_mid_mm + motor_arm_width;
    pt_start = find_interpolated_point(z_pos, points_le);   
    x_offset = 7;
    

    
    difference(){
        translate([pt_start[0]-x_offset,winglet_y_pos,z_pos])
            rotate([-90,0,0])
                winglet_design();
    
        intersection(){
            difference(){
                wing_shell();
                CreateAileron(); //We remove ailerons from wing if request
            }
            cube_cut(wing_root_mm + motor_arm_width+motor_arm_to_wing_hull, wing_mid_mm-motor_arm_to_wing_hull);
        }    
   }
   
   Create_winglet_connection();
}



///*** Function for connection between winglet to wing ***///
module Create_winglet_connection(cube_for_vase = false)
{
    
    points_le = get_leading_edge_points();
    z_pos = wing_root_mm + wing_mid_mm + motor_arm_width;

    cube_for_vase_y1 = attached_1_radius*10;
    cube_for_vase_z1 = attached_1_length;
    cube_for_vase_y2 = attached_2_radius*10;
    cube_for_vase_z2 = attached_2_length;    



  
    function interpolate_pt(p1, p2, target_z) =
        let (dz = p2[2] - p1[2], t = (target_z - p1[2]) / dz)
        [ p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1]), target_z ];

    function find_interpolated_point(target_z, pts) =
        let (
            pairs = [for (i = [0 : len(pts) - 2]) [pts[i], pts[i+1]]],
            valid = [ for (pr = pairs) if ((pr[0][2] <= target_z && target_z <= pr[1][2]) || (pr[1][2] <= target_z && target_z <= pr[0][2])) pr ]
        )
        (len(valid) > 0) ? interpolate_pt(valid[0][0], valid[0][1], target_z) : undef;

    pt_start = find_interpolated_point(z_pos, points_le);
    


    
    translate([pt_start[0]-attached_1_x_pos,attached_1_y_pos,z_pos+attached_z_offset]){
        rotate([180,sweep_angle,0])
            color("green") 
            if(cube_for_vase){ // In vase mode, we create the hole in the mid part, we therefore offset the hole to avoid too tight junction 
                cylinder(h = attached_1_length, r = attached_1_radius*winglet_attach_dilatation_offset_PLA, center = false);
            }
            else {
                 cylinder(h = attached_1_length, r = attached_1_radius, center = false);
            }
                
            if(cube_for_vase){
                rotate([0,sweep_angle,0])
                    translate([0,0,-cube_for_vase_z1])
                        color("green")   
                            cube([slice_gap_width,cube_for_vase_y1,cube_for_vase_z1]);
                 }
               
                }                
            
    translate([pt_start[0]-attached_2_x_pos,attached_2_y_pos,z_pos + attached_z_offset]){
        rotate([180,sweep_angle,0])
            color("green") 
            if(cube_for_vase){   // In vase mode, we create the hole in the mid part, we therefore offset the hole to avoid too tight junction         
                cylinder(h = attached_2_length, r = attached_2_radius*winglet_attach_dilatation_offset_PLA, center = false);
            }
            else {
                 cylinder(h = attached_2_length, r = attached_2_radius, center = false);
            }
            
            if(cube_for_vase){
                rotate([0,sweep_angle,0])    
                    translate([0,0,-cube_for_vase_z2])
                        color("green")   
                            cube([slice_gap_width,cube_for_vase_y2,cube_for_vase_z2]);
                 }
    }                

}

///*** Function for void connection between winglet to wing ***///
module Create_winglet_connection_void()
{

    points_le = get_leading_edge_points();
    z_pos = wing_root_mm + wing_mid_mm + motor_arm_width;
   
    
    
  
    function interpolate_pt(p1, p2, target_z) =
        let (dz = p2[2] - p1[2], t = (target_z - p1[2]) / dz)
        [ p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1]), target_z ];

    function find_interpolated_point(target_z, pts) =
        let (
            pairs = [for (i = [0 : len(pts) - 2]) [pts[i], pts[i+1]]],
            valid = [ for (pr = pairs) if ((pr[0][2] <= target_z && target_z <= pr[1][2]) || (pr[1][2] <= target_z && target_z <= pr[0][2])) pr ]
        )
        (len(valid) > 0) ? interpolate_pt(valid[0][0], valid[0][1], target_z) : undef;

    pt_start = find_interpolated_point(z_pos, points_le);

    translate([pt_start[0]-attached_1_x_pos,attached_1_y_pos,z_pos+attached_z_offset])
        rotate([180,sweep_angle,0])
            color("green") 
                cylinder(h = attached_1_length, r = attached_1_radius*winglet_attach_void_clearance, center = false);

            
    translate([pt_start[0]-attached_2_x_pos,attached_2_y_pos,z_pos+attached_z_offset])
        rotate([180,sweep_angle,0])
            color("green") 
                cylinder(h = attached_2_length, r = attached_2_radius*winglet_attach_void_clearance, center = false);  

                
                
}




///***                                           ***///
///*** Function winglet creation as wing design  ***///
///***                                           ***///

module WashoutSlice_winglet(index, current_chord_mm, local_wing_sections)
{

    washout_start_point = (winglet_mode == 1) ? (local_wing_sections * (washout_start_winglet / 100))
                                           : WashoutStart(0, local_wing_sections, washout_start_winglet, winglet_mm);
    washout_deg_frac = washout_deg_winglet / (local_wing_sections - washout_start_point);
    washout_deg_amount = (washout_start_point - index) * washout_deg_frac;
    rotate_point = current_chord_mm * (washout_pivot_perc_winglet / 100);

    translate([ rotate_point, 0, 0 ]) rotate(washout_deg_amount) translate([ -rotate_point, 0, 0 ])

        Slice_winglet(index, local_wing_sections);
}

module Slice_winglet(index, local_wing_sections)
{
        wingletAirfoilPolygon();
}

module WingSlice_winglet(index, z_location, local_wing_sections)
{

    // Function to calculate the rib cord length along an elliptical path
    function ChordLengthAtEllipsePosition_winglet(a, b, x) = b * pow(1 - pow(abs(x / a), elliptic_param_winglet), 1 / elliptic_param_winglet);
    
    
    current_chord_mm = (winglet_mode == 1) ? ChordLengthAtIndex(index, local_wing_sections)
                                        : ChordLengthAtEllipsePosition_winglet((winglet_mm + 0.1), winglet_root_chord_mm, z_location);
    scale_factor = current_chord_mm / 100;

    translate([ 0, 0, z_location ]) linear_extrude(height = 0.00000001, slices = 0)
        translate([ -winglet_center_line_perc / 100 * current_chord_mm, 0, 0 ])
            scale([ scale_factor, scale_factor,1 ]) 
           if (washout_deg_winglet > 0 &&
           ((winglet_mode > 1 && 
           index > WashoutStart(0, local_wing_sections, washout_start_winglet, winglet_mm)) ||
           (winglet_mode == 1 && index > (local_wing_sections * (washout_start_winglet / 100)))))
    {
        WashoutSlice_winglet(index, current_chord_mm, local_wing_sections);
    }
    else
    {
        Slice_winglet(index, local_wing_sections);
    }
}

module winglet_design(low_res = false)
{

    local_wing_sections = low_res ? floor(winglet_sections / 3) : winglet_sections;
    winglet_section_mm = winglet_mm / local_wing_sections;

    color("yellow")
    
    if (winglet_mode == 1)
    {
        translate([ winglet_root_chord_mm * (winglet_center_line_perc / 100), 0, 0 ]) union()
            {
        for (i = [0:local_wing_sections - 1])
        {
            z0 = winglet_section_mm * i;
            z1 = winglet_section_mm * (i + 1);

            y0 = use_custom_lead_edge_curve_winglet ? interpolate_y_winglet(z0) * curve_amplitude_winglet : 0;
            y1 = use_custom_lead_edge_curve_winglet ? interpolate_y_winglet(z1) * curve_amplitude_winglet : 0;

            x_off0 = use_custom_lead_edge_sweep_winglet ? interpolate_x_winglet(z0) : 0;
            x_off1 = use_custom_lead_edge_sweep_winglet ? interpolate_x_winglet(z1) : 0;

            hull()
            {
                translate([x_off0, y0, 0])
                    WingSlice_winglet(i, z0, local_wing_sections);
                translate([x_off1, y1, 0])
                    WingSlice_winglet(i + 1, z1, local_wing_sections);
            }
        }
        }
    }
    else
    {
        for (i = [0:local_wing_sections - 1])
        {
            z_pos = f(i, local_wing_sections, winglet_mm);
            z_npos = f(i + 1, local_wing_sections, winglet_mm);

            y0 = use_custom_lead_edge_curve_winglet ? interpolate_y_winglet(z_pos) * curve_amplitude_winglet : 0;
            y1 = use_custom_lead_edge_curve_winglet ? interpolate_y_winglet(z_npos) * curve_amplitude_winglet : 0;

            x_off0 = use_custom_lead_edge_sweep_winglet ? interpolate_x_winglet(z_pos) : 0;
            x_off1 = use_custom_lead_edge_sweep_winglet ? interpolate_x_winglet(z_npos) : 0;
            
            translate([ winglet_root_chord_mm * (winglet_center_line_perc / 100), 0, 0 ]) union()
            {
            
            hull()
            {
                translate([x_off0, y0, 0])
                    WingSlice_winglet(i, z_pos, local_wing_sections);
                translate([x_off1, y1, 0])
                    WingSlice_winglet(i + 1, z_npos, local_wing_sections);
            }
        }
        }
    }
}


//****************Tools function for interpolation**********//
// Y interpolation function from X (simple linear)
function interpolate_x_winglet(z) =
    let(
        i = search_index_z_winglet(lead_edge_sweep_winglet, z)
    )
    i == -1 ? 0 :
    let(
        z0 = lead_edge_sweep_winglet[i][0],
        x0 = lead_edge_sweep_winglet[i][1],
        z1 = lead_edge_sweep_winglet[i+1][0],
        x1 = lead_edge_sweep_winglet[i+1][1]
    )
    x0 + (z - z0) * (x1 - x0) / (z1 - z0);

function search_index_z_winglet(arr, z) = 
    (z < arr[0][0] || z > arr[len(arr)-1][0]) ? -1 :
    search_index_helper_z_winglet(arr, z, 0);

function search_index_helper_z_winglet(arr, z, i) = 
    (i >= len(arr) - 1) ? len(arr) - 2 :
    (z >= arr[i][0] && z < arr[i+1][0]) ? i :
    search_index_helper_z_winglet(arr, z, i + 1);
    
    
function interpolate_y_winglet(z) = let(i = search_index_z_y_winglet(lead_edge_curve_y_winglet, z))
    i == -1 ? 0 :
    let(z0 = lead_edge_curve_y_winglet[i][0], y0 = lead_edge_curve_y_winglet[i][1],
        z1 = lead_edge_curve_y_winglet[i+1][0], y1 = lead_edge_curve_y_winglet[i+1][1])
      y0 + (z - z0) * (y1 - y0)/(z1 - z0);

function search_index_z_y_winglet(arr, z) = 
    (z < arr[0][0] || z > arr[len(arr)-1][0]) ? -1 : search_index_helper_z_y_winglet(arr, z, 0);

function search_index_helper_z_y_winglet(arr, z, i) =
    (i >= len(arr)-1) ? len(arr)-2 :
    (z >= arr[i][0] && z < arr[i+1][0]) ? i :
    search_index_helper_z_y_winglet(arr, z, i+1); 
    
    